interface SubtitleEntry {
  id: string;
  startTime: number;
  endTime: number;
  text: string;
  translation?: string;
}

export interface ExportOptions {
  format: 'srt' | 'vtt' | 'ass';
  bilingual: boolean;
  language?: string;
  targetLanguage?: string;
  styling?: {
    fontName?: string;
    fontSize?: number;
    primaryColor?: string;
    outlineColor?: string;
    alignment?: number;
  };
}

// Format time for different subtitle formats
const formatTimeForSRT = (seconds: number): string => {
  const date = new Date(seconds * 1000);
  const hours = Math.floor(seconds / 3600);
  const minutes = Math.floor((seconds % 3600) / 60);
  const secs = Math.floor(seconds % 60);
  const ms = Math.floor((seconds % 1) * 1000);

  return `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')},${ms.toString().padStart(3, '0')}`;
};

const formatTimeForVTT = (seconds: number): string => {
  const hours = Math.floor(seconds / 3600);
  const minutes = Math.floor((seconds % 3600) / 60);
  const secs = Math.floor(seconds % 60);
  const ms = Math.floor((seconds % 1) * 1000);

  return `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}.${ms.toString().padStart(3, '0')}`;
};

const formatTimeForASS = (seconds: number): string => {
  const hours = Math.floor(seconds / 3600);
  const minutes = Math.floor((seconds % 3600) / 60);
  const secs = Math.floor(seconds % 60);
  const cs = Math.floor((seconds % 1) * 100); // centiseconds for ASS

  return `${hours}:${minutes.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}.${cs.toString().padStart(2, '0')}`;
};

// SRT Format Generator
const generateSRT = (subtitles: SubtitleEntry[], options: ExportOptions): string => {
  let content = "";

  subtitles.forEach((subtitle, index) => {
    const startTime = formatTimeForSRT(subtitle.startTime);
    const endTime = formatTimeForSRT(subtitle.endTime);

    let text = subtitle.text;
    if (options.bilingual && subtitle.translation) {
      text = `${subtitle.text}\n${subtitle.translation}`;
    } else if (subtitle.translation && !options.bilingual) {
      text = subtitle.translation;
    }

    content += `${index + 1}\n${startTime} --> ${endTime}\n${text}\n\n`;
  });

  return content;
};

// VTT Format Generator (WebVTT)
const generateVTT = (subtitles: SubtitleEntry[], options: ExportOptions): string => {
  let content = "WEBVTT\n\n";

  // Add metadata
  content += "NOTE\n";
  content += "Generated by SubtitlePro\n";
  if (options.language) {
    content += `Language: ${options.language}\n`;
  }
  content += "\n";

  subtitles.forEach((subtitle, index) => {
    const startTime = formatTimeForVTT(subtitle.startTime);
    const endTime = formatTimeForVTT(subtitle.endTime);

    // Add cue identifier
    content += `${index + 1}\n`;

    // Add timing line
    content += `${startTime} --> ${endTime}\n`;

    // Add text content
    let text = subtitle.text;
    if (options.bilingual && subtitle.translation) {
      text = `${subtitle.text}\n${subtitle.translation}`;
    } else if (subtitle.translation && !options.bilingual) {
      text = subtitle.translation;
    }

    // VTT supports styling
    if (options.styling?.primaryColor) {
      text = `<c.color>${text}</c>`;
    }

    content += `${text}\n\n`;
  });

  return content;
};

// ASS Format Generator (Advanced SubStation Alpha)
const generateASS = (subtitles: SubtitleEntry[], options: ExportOptions): string => {
  const styling = options.styling || {};

  // ASS Header
  let content = `[Script Info]
Title: SubtitlePro Export
ScriptType: v4.00+
Collisions: Normal
PlayDepth: 0

[V4+ Styles]
Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding
Style: Default,${styling.fontName || 'Arial'},${styling.fontSize || 20},&H${(styling.primaryColor || 'ffffff').replace('#', '')},&H000000FF,&H${(styling.outlineColor || '000000').replace('#', '')},&H80000000,0,0,0,0,100,100,0,0,1,2,0,${styling.alignment || 2},10,10,10,1

[Events]
Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text
`;

  subtitles.forEach((subtitle) => {
    const startTime = formatTimeForASS(subtitle.startTime);
    const endTime = formatTimeForASS(subtitle.endTime);

    let text = subtitle.text;
    if (options.bilingual && subtitle.translation) {
      text = `${subtitle.text}\\N${subtitle.translation}`;
    } else if (subtitle.translation && !options.bilingual) {
      text = subtitle.translation;
    }

    // Escape special characters for ASS
    text = text.replace(/\n/g, '\\N').replace(/\{/g, '\\{').replace(/\}/g, '\\}');

    content += `Dialogue: 0,${startTime},${endTime},Default,,0,0,0,,${text}\n`;
  });

  return content;
};

// Main export function
export const exportSubtitles = (
  subtitles: SubtitleEntry[],
  options: ExportOptions
): string => {
  switch (options.format) {
    case 'srt':
      return generateSRT(subtitles, options);
    case 'vtt':
      return generateVTT(subtitles, options);
    case 'ass':
      return generateASS(subtitles, options);
    default:
      throw new Error(`Unsupported format: ${options.format}`);
  }
};

// Batch export functionality
export interface BatchExportOptions {
  formats: ('srt' | 'vtt' | 'ass')[];
  bilingual: boolean;
  includeOriginal: boolean;
  includeTranslation: boolean;
  language?: string;
  targetLanguage?: string;
  styling?: ExportOptions['styling'];
}

export interface ExportResult {
  format: string;
  filename: string;
  content: string;
  size: number;
}

export const batchExportSubtitles = (
  subtitles: SubtitleEntry[],
  options: BatchExportOptions
): ExportResult[] => {
  const results: ExportResult[] = [];
  const baseFilename = `subtitles_${new Date().toISOString().split('T')[0]}`;

  // Generate exports for each requested format
  for (const format of options.formats) {
    // Original language export
    if (options.includeOriginal) {
      const content = exportSubtitles(subtitles, {
        format,
        bilingual: false,
        language: options.language,
        styling: options.styling
      });

      results.push({
        format,
        filename: `${baseFilename}_${options.language || 'original'}.${format}`,
        content,
        size: new Blob([content]).size
      });
    }

    // Translation export
    if (options.includeTranslation && subtitles.some(sub => sub.translation)) {
      const content = exportSubtitles(subtitles, {
        format,
        bilingual: false,
        language: options.targetLanguage,
        styling: options.styling
      });

      results.push({
        format,
        filename: `${baseFilename}_${options.targetLanguage || 'translated'}.${format}`,
        content,
        size: new Blob([content]).size
      });
    }

    // Bilingual export
    if (options.bilingual && subtitles.some(sub => sub.translation)) {
      const content = exportSubtitles(subtitles, {
        format,
        bilingual: true,
        language: options.language,
        targetLanguage: options.targetLanguage,
        styling: options.styling
      });

      results.push({
        format,
        filename: `${baseFilename}_bilingual.${format}`,
        content,
        size: new Blob([content]).size
      });
    }
  }

  return results;
};

// Download function for browser
export const downloadSubtitleFile = (filename: string, content: string): void => {
  const blob = new Blob([content], { type: 'text/plain;charset=utf-8' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = filename;
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  URL.revokeObjectURL(url);
};

// Batch download function
export const downloadBatchExports = (results: ExportResult[]): void => {
  results.forEach(result => {
    downloadSubtitleFile(result.filename, result.content);
    // Add small delay between downloads to prevent browser blocking
    setTimeout(() => {}, 100);
  });
};

// Get file extension and MIME type for format
export const getFormatInfo = (format: string) => {
  switch (format) {
    case 'srt':
      return { extension: 'srt', mimeType: 'text/plain' };
    case 'vtt':
      return { extension: 'vtt', mimeType: 'text/vtt' };
    case 'ass':
      return { extension: 'ass', mimeType: 'text/plain' };
    default:
      return { extension: 'txt', mimeType: 'text/plain' };
  }
};
